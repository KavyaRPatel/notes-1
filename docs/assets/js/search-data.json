[{"doc":"This page has not yet sprouted","title":"This page has not yet sprouted","hpath":"403","content":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","url":"https://sameep1234.github.io/notes/notes\\403.html","relUrl":"notes\\403.html"},{"doc":"Curated Notes","title":"Curated Notes","hpath":"root","content":"\nYou have reached the home page of my curated notes. I am a third year student pursuing Computer Science and Engineering at Ahmedabad University.\n\nFeel free to use this resource to its best potential and reach out to me on [Linkedin](https://www.linkedin.com/in/sameep-vani/) and do checkout my [GitHub](https://github.com/Sameep1234)","url":"https://sameep1234.github.io/notes","relUrl":"/"},{"doc":"Courses","title":"Courses","hpath":"courses","content":"\n","url":"https://sameep1234.github.io/notes/notes\\Jq5ki9jf1QLTdc3DYLRW4.html","relUrl":"notes\\Jq5ki9jf1QLTdc3DYLRW4.html"},{"doc":"Semester 5","title":"Semester 5","hpath":"courses.Semester 5","content":"\n","url":"https://sameep1234.github.io/notes/notes\\O93aKwUCEnkxTR7S8V2eZ.html","relUrl":"notes\\O93aKwUCEnkxTR7S8V2eZ.html"},{"doc":"Sensors","title":"Sensors","hpath":"courses.Semester 5.Sensors","content":"\n","url":"https://sameep1234.github.io/notes/notes\\BU8smu6Xa4e3tkB0iVHT9.html","relUrl":"notes\\BU8smu6Xa4e3tkB0iVHT9.html"},{"doc":"Lecture 4","title":"Lecture 4","hpath":"courses.Semester 5.Sensors.Lecture 4","content":"\n# TinkerCAD\n> This lecture included the demo of TinkerCAD and hence there are not much notes of it.\n\n## Extra Points\n* [Arduino Code Reference](https://www.arduino.cc/reference/en/)\n* Digital Read Function\n    * Pin from which digital input is read.\n    * Syntax: x = digitalRead(Inpin);\n* Analog Read\n    * Syntax: x = analogread(potPin);\n    * x ranges between 0 to 1023.\n* Serial Communication\n    * Syntax = Serial.begin(9600)\n    * This has to be used in setup part of the program structure.\n    * Will establish serial communication between computer monitor and Arduino.\n    * Syntax: Serial.println(\"ADC Output\");\n    * This will print it as a string on the monitor.\n* Digital to Analog Conversion calculation\n    * ![](/assets/images/2021-09-01-23-10-27.png)","url":"https://sameep1234.github.io/notes/notes\\WpnHrHHbJSgSeXE8haX51.html","relUrl":"notes\\WpnHrHHbJSgSeXE8haX51.html"},{"doc":"Lecture 3","title":"Lecture 3","hpath":"courses.Semester 5.Sensors.Lecture 3","content":"\n# Best Fit, Measurement and Control Systems\n\n## Points\n* With one value of x, take many values of y and then take the average\n* Error can occur at input as well as output side\n## Standard Error and Standard Deviation\n> Measures how much discrepancy (difference) is likely to be in the sample mean and the population mean.\n\n* Std Dev = Spread of data around the mean\n\n![](/assets/images/2021-08-27-09-42-54.png)\n* In excel, multiply by sqrt(nx) and divide by sqrt(nx-1) to get the correct result\n![](/assets/images/2021-08-27-09-44-23.png)\n## Precision\n> Degree of reproducibility of a measurement\n\n* Accuracy and precision are different. **Outputs** for calculation is close enough then your calculation is precise but accuracy depends on the whether the output values are close to the actual value means it is accurate.\n* It is also possible that the output is more accurate and less precise and vice versa.\n![](/assets/images/2021-08-31-23-19-59.png)\n\n## Resolution\n> Smallest measurable increment\n\n* Eg. Resolution of 1mv is greater than that of 10mv.\n* But it also depends on the type of application. If 100mv is the measurement required then 10mv is a nice resolution and 1mv resolution will be redundant\n## Span and Range\n> Span: Linear operating range\n\n* This means that the relationship between two values must be a linear relation.\n\n> Range: Simple range (No explanation needed)\n\n## Best Fit Line\n![](/assets/images/2021-08-27-10-03-26.png)\n* Error is the difference between best fit value and the actual value.\n\n![](/assets/images/2021-08-27-10-09-13.png)\n> We take n-2 because measured values are mean and not true values and two variables are involved.\n\n## Computerized measurement and control systems\n\n## Development of software\n> Question to think: How to store the software or computer program in the circuit board?\n\n* General purpose computer is required to build a software for specific purpose computer.\n* Write the code in the laptop and then upload the code on the board.\n\n## Arduino Board\n* Components\n    * Input Pins (6 Analog Pins)\n    * Battery Connector/Receptor\n    * Output Pins (Analog)\n    * USB Connector\n    * 14 Digital pins which can be used as either input or output i.e the pins are configurable.\n* Voltages range from 0V to 5V.\n* PWM - Pulse wave modulated (Explained in further letures).\n* On the actual arduino board, they are represented by a '~' sign.\n* Pin13 has built in LED for testing and hence doesn't require any external LED's in order to test the program.\n\n## Analog to Digital converter\n* For a 10 bit ADC which is generally found in arduino, there would be 1024 values starting from 0 and going to 1023 with increment as 1.\n* This, means that value corresponding to 1023 is 5V.\n* **ADC are linear.**\n\n## Sampling rate of ADC\n* Sampling rate = 9650 samples/sec. This is fixed for an arduino board.\n* Maximum theoretical frequency of the input analog signal is half of this.\n\n## Pulse Wave Modulation (PWM)\n![](/assets/images/2021-09-01-22-26-19.png)\n* As seen in the above figure, Tw is the pulse width and T is the time period of the wave.\n* Average value of periodic wave = $\\frac{Area under one time period}{Time period}$\n* Duty cycle ranges from 0 to 255 corresponding to 0% and 100% respectively.\n\n## Program Structure\n* ![](/assets/images/2021-09-01-22-31-18.png)\n* **Statements under setup function will be executed only once and vice versa for loops.**","url":"https://sameep1234.github.io/notes/notes\\2p4SrKmDTQWH2LLlK15oP.html","relUrl":"notes\\2p4SrKmDTQWH2LLlK15oP.html"},{"doc":"Lecture 2","title":"Lecture 2","hpath":"courses.Semester 5.Sensors.Lecture 2","content":"\n# Callibration of Sensors and Errors\n\n## Advantages of Linear sensors\n* Callibration will be easy.\n* Scale would be crowded for non-linear sensor at lower temperature range.\n* Calculation becomes easier.\n\n## Extra Points\n* ADC is always linear.\n* Equation written in the program will be stored in the processor.\n* Sometimes, the equation is complicated and hence it becomes difficult for processor to sovle that equation.\n* To solve this, we use table look up. In this, we form a table of x and y values and then search for a particular value. We can use some of the most efficient search algorithm.\n* Callibration means to create a table between the two variables.\n\n## Algorithm for Digital instrument\n* Start ADC by sending a pulse at the start of conversion line and then will wait for end of conversion line.\n* Then read y1 (always an integer discrete value because it is output is binary).\n* Calculate inverse function of x or look up in the table.\n* Display because we want the value to be stable for some point.\n* Add delay.\n* Repeat the above procedure.\n\n## Error and Accuracy\n\n> Difference between measured and true value.\n\n* Formula\n![](/assets/images/2021-08-31-15-32-11.png)\n\n> Accuracy means values that are aligned with standard rules or laws.\n\n* Exact true value to be found is not possible. Thus, we require the best standards and these are called as primary standards.\n* These do no change with temperature, pressure etc.\n* Secondary standards are less accurate and are calibrated using primary standards.\n* These can also be costly and thus we use working standards.\n* Types of errors\n    * Systematic error\n        * Instrument inaccuracies\n        * Faulty design of an experiment\n    * Random errors\n        * Human errors\n        * Noise\n![](/assets/images/2021-08-31-16-01-54.png)\n\n## Calibration procedure\n![](/assets/images/2021-08-31-15-37-26.png)\n* Measure the values generated by intrument under the test and compare it with the values generated by secondary and working stadndards.","url":"https://sameep1234.github.io/notes/notes\\3n3DMUBNlHzi2EvIp0oiA.html","relUrl":"notes\\3n3DMUBNlHzi2EvIp0oiA.html"},{"doc":"Lecture 1","title":"Lecture 1","hpath":"courses.Semester 5.Sensors.Lecture 1","content":"\n# Introduction to course\n\n## Course Material\n* Principles and applications of Electrical Engineering, 5th Edition by Giorgio Rizzoni, McGraw-Hill\n\n## Assessment and Evaluation\n* Quiz 1: 11%\n* Mid Semester Exam: 22%\n* Quiz 2: 6%\n* Assignments: 11%\n* Project: 15%\n* End Semester Exam: 35%\n* **Open Book Exam on LMS**\n\n> ## **Absolute Grading System**\n\n![](/assets/images/2021-08-29-20-32-26.png)\n\n## Extra Points\n* Engineering applications always require accurate measurement and control over physical quanities.\n* It is easy to transmit signal in electrical form.\n* We might need to process the signal and it is easier to perform operations in electrical form.\n* Thus, we need sensors.\n\n## Transducers and Sensors\n* Convert one form of signal to another form.\n* If you convert non-electrical signal to an electrical signal, it is called a sensor.\n* Thus, sensors are subset of transducers.\n* Actuator is device converting electrical to non-electrical signal.\n\n## Sensor Calibration\n![](/assets/images/2021-08-30-10-01-01.png)\n\n> We need curve fitting to obtain equation from the data points.\n\n## Curve Fitting\n* Process of finding suitable equation between y and x when table of values of x and y is known.\n* Polynomial form in general case\n* Steps in excel\n    * Select the data points.\n    * Go to insert.\n    * Select scatter plot.\n    * Chart will appear.\n    * Right click on any data point on the chart and select trendline option.\n    * Choose Polynomial and select the appropriate order.\n    * **Check the display equation and display R^2 in chart option.**","url":"https://sameep1234.github.io/notes/notes\\yTD0dP4MoWNKpCeht3Wz3.html","relUrl":"notes\\yTD0dP4MoWNKpCeht3Wz3.html"},{"doc":"Operating System","title":"Operating System","hpath":"courses.Semester 5.Operating System","content":"\n","url":"https://sameep1234.github.io/notes/notes\\OGq6U8MXIG3wwETNLR4b6.html","relUrl":"notes\\OGq6U8MXIG3wwETNLR4b6.html"},{"doc":"Lecture 5","title":"Lecture 5","hpath":"courses.Semester 5.Operating System.Lecture 5","content":"\n## Suspended Process\n* It is possible that at one point all the processes are waiting for I/O and processor will remain idle.\n* Issues to address\n    * Processor could be idle most of the time.\n* Solution\n    * **Swap these processes to disk to free RAM and execute some new processes**.\n* Blocked state, thus, becomes suspend state when swapped to disk.\n* Now 5-state gets converted to 6-state model\n\n## 6-state model\n* ![](/assets/images/2021-09-01-08-08-39.png)\n* Notice that blocked processes are transferred to suspended processes but suspened processes are directly transfered to ready state.\n* OS now has two ways\n    * Admit new processes\n    * Activate previously suspended processes\n* Subsets of suspend state\n    * Blocked/Suspend: Process in secondary memory and awaiting an event.\n    * Ready/Suspend: \n\n## 7-state model\n* ![](/assets/images/2021-09-01-08-13-46.png)\n* Newly created process will remain in ready/suspend state until there is memory avaible to move it to ready state.\n* Eg. When booting up, memory is awailable and hence it is possible to directly admit new process into ready state.\n* New state transitions\n    * ![](/assets/images/2021-09-01-08-22-08.png)\n\n## Characterisitcs of suspended processes\n* Process not immediately available for execution because it is in secondary memory.\n* It may or may not be waiting for an event. It may be moved only to free some RAM.\n* \"Agent\" puts the process in suspended state. Agents include either itself (Eg. Some process which occur only periodically), parent procees or OS in order to preclude its execution.\n* Process may not be removed until agent orders the removal. Most of the time agent is OS.\n\n## Reason for process suspension\n* ![](/assets/images/2021-09-01-08-32-36.png)\n\n## Relation between process and resource\n> Recap: OS is a resource manager. Process is a program in execution.\n\n![](/assets/images/2021-09-01-08-38-45.png)\n* **Main memory as a resource means**\n* Virtual memory is extention of secondary memory into main memory.\n* Some part of HDD is considered in RAM.\n\n## Data Structures\n* OS must have information about current status and all processes and all resources.\n* Thus, OS maintains tables for each of the functionalities it offers\n* Memory Table\n    * Keep tracks of main and secondary memory.\n    * Must include information\n        * Allocation of main memory to processes.\n        * Allocation of secondary memory to processes.\n        * Protection attributes for access to shared memory regions.\n        * Information required to manage virtual memory.\n* I/O Table\n    * Manage I/O device and channels of computer.\n    * Must include information\n        * Availability of I/O device.\n        * Status of I/O operation whether I/O device is available or not.\n        * Location in main memory for source and destination\n* File Table\n    * Must include information\n        * Existence of files.\n        * Location on secondary memory.\n        * Current Status.\n        * Others (Who can access? etc.)\n* Process Table\n    * Must include information\n        * Location of **process** in the memory.\n        * Process attributes.\n    * Memory, I/O and files are managed on behalf of processes, so there has to be some reference to these resources in process tables. (Like foreign key)\n\n## Physical manifestation of a process\n> Menifestation means presentation.\n\n![](/assets/images/2021-09-01-08-53-11.png)\n\n* Elements of process image\n    * User Data\n    * User Program\n    * User Stack\n    * Process Control Block (PCB)\n\n## Process Location\n* It is not required in main memory. Someting called virtual memory also exists.\n* Process image is maintained as a contiguous block of memory (**in secondary memory**).\n* Maintained in secondary memory (majority of its part).\n* Some part should be loaded in main or at least in virtual memory.\n* Moreover, to execute process, some part must be in main memory.\n* Thus, only needs to know which parts of process are in main and secondary memory and where are they located.\n\n## Attributes in PCB\n* Process identification\n* Processor state information\n* Process control information\n\n## Process Identification\n* Identifier of this process.\n* Identifier of parent process.\n* User identifier (To which user this process belongs to?)\n\n## Processor state information\n* Need to watch lecture again from here. ","url":"https://sameep1234.github.io/notes/notes\\WRmiZB2hMRgBOBAUqcUGI.html","relUrl":"notes\\WRmiZB2hMRgBOBAUqcUGI.html"},{"doc":"Lecture 4","title":"Lecture 4","hpath":"courses.Semester 5.Operating System.Lecture 4","content":"\n# Process: Description and Control\n\n## Requirements of OS as a Process Manager\n* Interleave the execution of multiple processes. Here we assume that there is always a single processor system.\n* Allocate resources to processes and protect them from each other.\n* Enable process to share and exchange information. Eg. Parent and Child processes.\n* Enable synchronization among processes.\n\n## Process\n* Program in execution.\n* Instance of program running\n* Entity that can be assigned to and executed on a processor\n* **Unit of activity defined by program, its states and its associated resources.**\n* Process Elements\n    * Program code (generally shared)\n    * Set of data\n    * Attributes that describes the state\n    \n## Attributes\n* Indentifier - Unique ID of each process\n* State - Current situation of the process (Either running or not running)\n* Priority - Self explanatory\n* Program Counter - Keeps information about next process to be executed\n* Memory pointers - Pointers to program code and data to be processed. Along with this, it also includes shared memory blocks.\n* Context data\n* I/O status information - Eg. List of files in use by the process etc.\n* Accounting information - Eg. Time limits, clocks used etc.\n\n> In short the attributes can be called as meta-data.\n\n## Process Control Block (PCB)\n* All the attributes discussed above are part of this block.\n* Basically, it is a type of data structure.\n\n> **Thus, process is a combination of program code, associated data and PCB**\n\n## Running on single resource\n* To manage multiple processes on a single resources then scheduling comes to the picture.\n* Thus, you allocate certain span of time to each process and once it gets finished, immediately another process starts.\n* It gives an appearance that every process runs at the same time because the total time taken by all the process combined is really small.\n* **Trace - List of instructions that are executed by a process.**\n* **Dispatcher - Program that switches the processor from one process to another.** It is a type of short term scheduler.\n\n## Execution of Processes by Processor\n* Suppose that there are some processes which have a lot of instructions to execute. This might take time which is greater than the allocated one.\n* So in the middle of the execution of a process, dispatcher stops the execution and decides which process should go next.\n* Once decided, either execution of new process starts or execution of old process continues.\n* Then, suppose there is an I/O request. Since this is a slow operation, the dispatcher will allow another process to run on the processor.\n* This goes on and on untill all the processes are executed.\n\n> The above method is from **processor POV** and is called **interleaving of processes** and the OS manages this through **dispatcher**. From **process POV**, the process gets executed sequencially.\n\n## Process States\n* Two states\n    * Running\n    * Not running\n* Transition from **not running** to **running** state is called **dispatch** and is called **pause** for the opposite scenario.\n* There can be at most only one process in running state at a given instance of time.\n* There are 'n' number of processes in the non-running state.\n* Thus, to manage all these processes, we need **queue** as the data structure.\n\n## Note\n* The below picture lists conditions under which a process can be created or terminated.\n* ![](/assets/images/2021-08-29-15-16-50.png)\n\n* Process spawning means event where a process creates a new process.\n\n## 5-State Process Model\n* Conditions when the process which is running will pause and enter in the queue:\n    * Time slot alloted to the process is over.\n    * Made some I/O request which may take time.\n* Now, dispatcher needs to identify which processes are ready to be executed and then dispatch it from the middle of the queue.\n* This process is time consuming and complex.\n* To resolve this, OS must maintain multiple queues. Since there are two types of processes, one who did not terminate but their allocated time got over and others who are waiting for I/O or other resouces.\n* This, in turn is the 5-state process model.\n* Total states in this model\n    * New - Process that has just been created but not admitted to the pool of the ready state processes.\n        * **Not loaded in main memory but is created.**\n        * This means that PCB for that process has been created but its corresponding data and program has not been loaded/created in the main memory.\n    * Ready\n    * Blocked/Waiting\n    * Running\n    * Exit (Earlier it was not a state but now it is) - Process which has been released from the pool of processes.\n        * However, there is some part of PCB left in main memory for accounting.\n\n![](/assets/images/2021-08-29-15-32-07.png)\n\n## State Transitions\n\n* ![](/assets/images/2021-08-29-15-36-29.png)\n\n* Ready and Blocked process can enter directly to exit state when its parent process has terminated or the process is terminated by the OS.\n* When process spawning occurs, then child process is created in the new state.\n* Hang state is equivalent to blocked/waiting state.\n\n## Multiple Blocked Queue\n* Suppose there are 10 processes which are in blocked queue waiting for HDD to get accesible and there are 90 processes that are in hang mode.\n* Now once HDD is ready to be accessed, OS will have to search this blocked queue and move all these processes to ready state.\n* This is again time consuming and complex. Hence multiple blocked queue model emerged.\n\n![](/assets/images/2021-08-29-15-48-46.png)","url":"https://sameep1234.github.io/notes/notes\\0cHUe8OjK8Sb4TkMg9EhP.html","relUrl":"notes\\0cHUe8OjK8Sb4TkMg9EhP.html"},{"doc":"Lecture 3","title":"Lecture 3","hpath":"courses.Semester 5.Operating System.Lecture 3","content":"\n\r\n# System Calls and Architecture of UNIX\r\n\r\n## Intro to system calls\r\n* System calls are the most important and crucial concept in OS. It is basically a link connecting user to the OS.\r\n* Formally, it is a **programming interface (like waiter connecting customers to kitchen in a restaurant)** to use the services provided by the OS. They are the programs that help give access to the functionalities provided by the OS.\r\n*  They are written in a high-level language like C or C++.\r\n* POSIX API is used for Linux and Win32 API is used for windows.\r\n\r\n## Implementation of System Call\r\n* Associated with each function call. Eg. If you call a function printf() in C, then it internally calls an associated system call telling the OS to display the written part on the scree.\r\n* Every OS have a list of system call along with ID's.\r\n* System call interface maintains a table with ID's as indices.\r\n* This interface invokes a particular system call in OS kernel and returns the status and return-values if any.\r\n* Details are hidden from programmer by the API.\r\n\r\n## Relationship between API, System Call and OS\r\n\r\n![](/assets/images/2021-08-29-10-48-06.png)\r\n\r\n## Types of system calls\r\n* File Management - Eg. create, open, close etc.\r\n* Device Management - request, release, read, write etc.\r\n* Protection - control access, get and set permissions etc.\r\n* Information maintenance - get time, set process etc.\r\n* Communications - create, delete communication, send or recieve messages etc.\r\n\r\n### Architecture of UNIX\r\n\r\n* ![](/assets/images/2021-08-29-11-08-15.png)\r\n\r\n* UNIX is an OS just like Linux.\r\n* In fact linux is based on UNIX but is more complicated than UNIX.\r\n* UNIX system follows monolithic approach\r\n* UNIX System Kernel\r\n\r\n![](/assets/images/2021-08-29-11-10-53.png)\r\n\r\n* **In Linux or UNIX, everything is in terms of files. Thus, it becomes crucial to understand file system.**","url":"https://sameep1234.github.io/notes/notes\\Oj3uiXKth6ZgUASqln4Vi.html","relUrl":"notes\\Oj3uiXKth6ZgUASqln4Vi.html"},{"doc":"Lecture 2","title":"Lecture 2","hpath":"courses.Semester 5.Operating System.Lecture 2","content":"\n\r\n# Evolution of OS and Kernel\r\n\r\n## Evolution of OS\r\n* Serial Processing\r\n* Simple Batch Systems\r\n* Multiprogrammed Batch Systems\r\n* Time Sharing Systems\r\n* many others\r\n\r\n## Serial Processing\r\n* There was no OS.\r\n* To run the program, we would have to type a command for everything.\r\n* A program at that time was called a job which is a set of instructions along with the data on which the instructions need to be executed.\r\n* Issues\r\n    * Scheduling\r\n        * Fixed amount of time allocated to each instruction.\r\n        * Conflict between instructions requiring more or less time.\r\n    * Setup Time\r\n        * Loading of compiler and program is time consuming\r\n\r\n## Simple Batch System\r\n* Monitor Program were used which were kind of OS - A very rudimentary OS.\r\n* It is a software that controls the sequence of events.\r\n* No direct access to users unlike Serial Processing.\r\n* Job is submitted to an operator who batches similar instructions together and places them on the input device/hardware.\r\n* In this way, the time consumed is averaged out and the processor can be utilized to its maximum.\r\n* Control is given back to monitor after program gets terminated.\r\n\r\n> Monitor is a special program that manages execution of each program in the **batch**. It controls the sequence of events. Resident monitor (another name for simple monitor) is software always in memory. It reads in job and gives control to the processor which in turn returns the control back to monitor\r\n\r\n> Processor executes instructions from the memory i.e monitor which resides in the memory. It gains control from monitor to execute the task and once completed returns the control to monitor.\r\n\r\n> JCL (Job control language) - It is a programming language that provides instruction to the monitor about the compiler and data to be used.\r\n\r\n* Modes of operation\r\n    * User mode (Analogy: Normal Mode) - Programs submitted by the user to the memory are executed in this mode. **Not all instructions may be executed.**\r\n    * Kernal mode (Analogy: Admin Mode) - Part of a modern OS that actually performs I/O Management, Process Management etc. Nowadays, we have many other utility programs running which are a part of OS, but kernal is the most important one which manages the above mentioned things.\r\n\r\n* Issues\r\n    * Processor remains idle.\r\n    * Slow compared to processor even with automatic job sequence.\r\n\r\n![](/assets/images/2021-08-28-23-38-27.png)\r\n\r\n## Uniprogramming\r\n\r\n> Processor must wait for I/O instruction to complete before proceeding further.\r\n\r\n## Multiprogramming\r\n\r\n> Opposite of uniprogramming. Still there will be some waiting time but at least it can be reduced and hence is better than uniprogramming.\r\n\r\n## Time sharing systems\r\n* The program is being shared through different users and different monitors. Thus, can be used to handle multiple interactive jobs.\r\n* Processor time is shared among multiple users.\r\n* This time is in milli or micro seconds. This is called short burst or quantum of computation.\r\n\r\n![](/assets/images/2021-08-29-00-06-36.png)\r\n\r\n## OS Structure\r\n* *For general purpose OS, the program is very large.*\r\n* Ways to structure OS\r\n    * Monolitic Approach (Analofy coding in C where there are no classes) - Everything combined in one place.\r\n        * Eg. Older LINUX and UNIX\r\n        * Advantages\r\n            * Speed as everything is connected\r\n            * Performance\r\n        * Disadvantages\r\n            * Difficult to maintain and modify\r\n    * Layered Approach - OS divided into number of layers.\r\n        * Layer 0 = hardware and Layer n = user interface layer\r\n        * A particular layer can use functions and services of **lower-level layers only (layers below it).**\r\n        * Eg. Older windows versions\r\n    * Microkernels - Move as much functionalities as possible to user mode from kernel mode. \r\n        * Unlike that in layered and monolithic where majority of the functionalities is available in only kernal mode.\r\n        * I\\O and interrupt management, primitive memory management, inter-process communication and basic scheduling were kept in kernel mode.\r\n        * All other functionalities will be running in user mode.\r\n        * Advantages\r\n            * Time is reduced significantly as the time to change the mode from user to kernel and vice versa is almost completely diminished.\r\n            * Porting of OS to newer architecture becomes easier (will be covered in upcoming lectures).\r\n            * More reliable because less code is running in kernel mode.\r\n            * More secure as less code has to be valudated in kernel.\r\n        * Disadvantages\r\n            * Performance overhead to change the mode.\r\n        * Eg. Mach, MINIX, Windows NT Client-Server\r\n    * Modules - Most moedern OS implement kernel modules\r\n        * These are loadable kernel module\r\n        * Uses OOP\r\n        * Similar to layers but is more flexible\r\n        * Eg. Device Drivers (These are loaded as needed within the kernel)\r\n        * Solaris Modular Approach (will be covered in upcoming lectures).\r\n    * Hybrid Approach - Combines multiple approaches to address performance, security and usability.\r\n        * Eg. Linux and Solaris = monolithich + modular, windows = monolithic + microkernel and Mac OS and IOS = Darwin which is microkernel and BSD Unix kernel implemented over layered model","url":"https://sameep1234.github.io/notes/notes\\YWtnvQOHrej4digmZkK86.html","relUrl":"notes\\YWtnvQOHrej4digmZkK86.html"},{"doc":"Lecture 1","title":"Lecture 1","hpath":"courses.Semester 5.Operating System.Lecture 1","content":"\n# Introduction to Operating System\n\n## Course Material\n* Textbook - Operating Systems: Internals and Design Principles, 9th Edition, by William Stallings, Pearson\n\n## Computing System\n\n> Basic purpose is to perform computation on input data and generate results\n\n* Comprised of hardware, software and data.\n* Secondary storage stores all the programs (like code in C).\n* To execute it, first load it into the memory (RAM).\n* For any program to run by the processor, first fetch, then execute and then finally check for the interrupts.\n\n> Operating System will perform the task of loading the program from secondary memory (Hard Disks) to main memory (RAM)\n\n## Functions of OS\n* I/O Management\n* Process Management\n* Memory Management\n* File Management\n\n> Operating system is a program that acts as an intermediary between a user of a computer and the computer hardware.\n\n## Objectives of OS\n* Convenience - Makes computer easy to use\n* Efficiency - Manages resources efficiently\n* Ability to evolve - Easy to adapt changes\n\n## Users of Computing System\n* End User - Use the application as it is. Eg. Excel Users\n* Programmer - Developing applications. Need to understand utility programs and OS\n* Operating System Designer/System Level Programmer - Creates OS/**Works with computer hardware**/Develop or write a driver\n\n> Driver is a piece of software that understands a hardware. It understands the internals of the attached hardware.\n\n## Services provided by OS\n\n> Through these services OS attains \"Convenience\".\n\n* Program development\n* Program execution\n* Access I/O devices (Eg. CDs, Pendrives)\n* Controlled access to files (Provides protection in multi-access systems (Eg. Multiple users in same laptop))\n* System access\n* Error detection and response (Eg. Errors in reading CDs)\n* Accounting (Collect usage statistics/Monitor performance)\n\n## Resource Management\n* Movement\n* Storage\n* Processing of data\n\n> OS is a program that is executed by the CPU! (Kind of ironic. OS handles CPU but is executed by CPU XD)","url":"https://sameep1234.github.io/notes/notes\\ze7K28mUdIHg5Z137Vucz.html","relUrl":"notes\\ze7K28mUdIHg5Z137Vucz.html"},{"doc":"Music","title":"Music","hpath":"courses.Semester 5.Music","content":"\n","url":"https://sameep1234.github.io/notes/notes\\YfEhInqFt0RCqjRYQvTlf.html","relUrl":"notes\\YfEhInqFt0RCqjRYQvTlf.html"},{"doc":"Lecture 1","title":"Lecture 1","hpath":"courses.Semester 5.Music.Lecture 1","content":"","url":"https://sameep1234.github.io/notes/notes\\BpPndOdyo69WT64AEoDns.html","relUrl":"notes\\BpPndOdyo69WT64AEoDns.html"},{"doc":"Material Science and Engineering","title":"Material Science and Engineering","hpath":"courses.Semester 5.Material Science and Engineering","content":"\n","url":"https://sameep1234.github.io/notes/notes\\SkPPj7voTTRpF7d0XMYNV.html","relUrl":"notes\\SkPPj7voTTRpF7d0XMYNV.html"},{"doc":"Lecture 4","title":"Lecture 4","hpath":"courses.Semester 5.Material Science and Engineering.Lecture 4","content":"\n# Directions and Planes\n\n## Density Computation\n* $\\rho$ = $\\frac{nA}{VcNa}$\n* Here $\\rho$ is the density, n is the number of atoms in a unit cell, A is the atomic mass of the element, Vc is the volume of unit cell and Na is the avogadro's number.\n\n## Crystal Directions\n> These include linear density and planar density\n\n* ![](/assets/images/2021-08-29-18-16-42.png)\n\n> Always divide by the biggest number. Eg. 4th case in the above image.\n\n## Extra points\n* To represent direction, use square brackets.\n* To represent plane, use round brackets.\n* Parallel planes belong to the same **family** of planes.\n* To represent family of planes, use curly brackets.\n* To represent family of directions, use angular brackets.\n* There should not be comma between numbers in either of the cases.\n\n\n> Why are planes in a lattice important?\n* Determining crystal structure\n* Plastic deformation\n* Transport properties\n\n## Miller Indices\n* This is one of the information required to study X-Ray defractogram\n* Procedure to find these indices\n    * Note the intercepts made by plane in terms of **lattice constants** a,b and c.\n    * Note the coefficient of the intercepts.\n    * Find inverse of them.\n    * Find LCM and multiply them by LCM.\n    * These points that you get are the Miller indices.\n\n> Example of calculating Miller indices\n\n![](/assets/images/2021-08-29-18-27-28.png)\n\n## How to draw planes?\n* Quite confusing, read book\n\n## Angle between planes\n![](/assets/images/2021-08-29-18-43-28.png)\n\n## Linear and Planar Density\n![](/assets/images/2021-08-29-18-45-11.png)\n\n* This is **atomic** density.","url":"https://sameep1234.github.io/notes/notes\\0MwJpw5Ai8WlLrE5bLyaQ.html","relUrl":"notes\\0MwJpw5Ai8WlLrE5bLyaQ.html"},{"doc":"Lecture 3","title":"Lecture 3","hpath":"courses.Semester 5.Material Science and Engineering.Lecture 3","content":"\n# Crystal Lattice\n\n### Sorry for the inconvinience but please refer this [site](https://unread.parthshah.ml/notes/omAwLOv3wYSYrihgzYlu4.html) for lecture 3 notes.","url":"https://sameep1234.github.io/notes/notes\\hvEDw5kSoIcX03j2YJdL9.html","relUrl":"notes\\hvEDw5kSoIcX03j2YJdL9.html"},{"doc":"Lecture 2","title":"Lecture 2","hpath":"courses.Semester 5.Material Science and Engineering.Lecture 2","content":"\n# Atomic Structure, Bonding and Energy\n\n## Classification of materials\n![](/assets/images/2021-08-28-10-22-07.png)\n\n* Types of materials\n    \n    * Semiconductor\n    * Polymer\n    * Metals\n    * Ceramics\n    * Biomaterials\n    * Composites\n\n> Composite material is formed by the combination of two or more types of materials. But why do we need composite materials?\n\n* Reduce Weight\n* Lowers the cost of the material\n* Gives strength to the device\n* **Mediates propogation of charge/current**\n\n## Atomic structure\n\n* Atomic mass unit = 1/12 of the mass of most common isotope of carbon.\n* Atomic weight is weighted average of atomic masses of naturally occuring isotopes.\n* A mole is amount of matter with mass in grams equal to atomic mass in amu.\n* A mole of carbon has a mass of 12 grams.\n* **One mole has 6.023 x 10^23 number of atoms (also called as Avogadro's number)**\n* Number density formula: \n\n![](/assets/images/2021-08-28-15-14-09.png)\n\nHere Nav = avogadro's number, $\\rho$ = mass density and A = atomic mass\n\n* De broglie wavelength: \n\n![](/assets/images/2021-08-28-15-58-00.png)\n\n* Heisenberg Uncertainty Principle: \n\n![](/assets/images/2021-08-28-15-58-34.png)\n\n### Electronic Structure of isolated atoms\n* n  principal shell (1,2,3... or K,L,M...)\n* l = anular (sub shell) (s,p,d,f)\n* ml = magnetic (-l to +l including 0)\n* ms = spin (1/2, -1/2)\n\n> Ionization potential is the energy required to pull out a valence electron (in vacuum) and by convention it is positive. Electron affinity is energy gained by putting an electron in (from vacuum) and by convention it is negative.\n\n> Electronegativity is the measure of how likely an atom will take up or give up an electron.\n\n* Valence electrons determine the physical properties viz chemical, electrical, thermal and optical\n* Electropositive elements easily give up electrons to become positive ions. These generally rest in the left sife of the periodic table and vice versa for electronegative elements.\n* This means electronegativity is smaller on left side and larger on the right side.\n\n## Physical properties in Periodic table\n![](/assets/images/2021-08-28-16-08-27.png)\n\n## Bonding in solids\n* At large distances, interactions are negligible and at small distances each atom exerts forces on the other.\n* These include, force of attraction and that of repulsion.\n\n![](/assets/images/2021-08-28-16-12-56.png)\n\n* Fnet = Fr + Fa. At equilibrium Fnet = 0\n\n## Potential Energy\n\n> **Here potential energy and energy are used interchangebly.**\n\n* Energy is integration of foice wrt the radius.\n* Enet = Ea + Er.\n\n![](/assets/images/2021-08-28-16-17-07.png)\n\n* Attraction energy = -A/r and Repulsive energy = B/power(r,n)\n* E0 = Bonding energy at minimum distance. This means that it is the energy required to seperate two atoms.\n* It the curve above is deep, this implies that the material is rigid and inflexible and vice versa.\n* If the double derivative of the energy (equivalent to single derivative of force equation) equation at r = r0 is less than 0 then it is stable and vice versa.\n* To find the equalibrium position, make the single derivative of the energy equation (equivalent to the force equation) equal to 0.\n\n## Ionic Bonding\n* **Difference between electronegativity is of prime importance. Ionic bonding only occurs between atoms with large differences in electronegativity.**\n* Cation = Positive Ion, Anion = Negative Ion\n* Primary Bonding means that electrons are completely transferred. Atoms do so to acheive stable configuration. Such type of bonding is very strong (columbic force in case of ionic bonding). (Eg. Ionic, Covalent and Metallic)\n* Ionic bonds are non-directional whereas covalent bonds are directional in nature.\n* Secondary Bonding means that electrons are shared. This type of bonding is weaker compared to primary bonding. (Eg. inert gases (H2, Cl2) or permanet dipoles (H20, HCl))\n* Enet (due to all attractions and repulsions) is known as **madelung energy**.\n\n## Covalent Bonding\n* **Covalent bonding occurs between atoms with small differences in electronegativity.**\n* Percent of ionic characters:\n\n![](/assets/images/2021-08-28-16-46-57.png)\n\n* Here Xa and Xb are the electronegativities of elements a and b. Greater the difference between electronegativities, greater is the ionic bonding and vice versa.\n\n## Summary of Bonding\n\n![](/assets/images/2021-08-28-16-50-27.png)","url":"https://sameep1234.github.io/notes/notes\\3Ez0kXjxHUD43Yc6H2vMR.html","relUrl":"notes\\3Ez0kXjxHUD43Yc6H2vMR.html"},{"doc":"Lecture 1","title":"Lecture 1","hpath":"courses.Semester 5.Material Science and Engineering.Lecture 1","content":"\n# Introduction to Material Science and Engineering\n\n## Points to Ponder\n* With slight change in physical properties, we can get a whole new material. These are **amorphous** and **crystalline**.\n* Difference between LED and solar cell is that one emits the light and other absorbs the light.\n\n## Assessment and Evaluation\n* Mid Sem Exam - 25%\n* End Sem Exam - 30%\n* Lab Work (including viva (15%) and theory exam (10%)) - 25%\n* Project - 10% (Based on ppt presentation and viva)\n* Tests/Quizes - 10% (Two Quiz of 5% each)\n\n## Project Details\n* Submit a report\n* Viva will be conducted\n\n## Course Material\n* Textbook - Materials Science and Engineering: An Introduction, William D Callister 6th Edition, John Wiley & Sons.\n\n> Central Paradign of Material Science and Engineering\n\n![](/assets/images/2021-08-28-10-09-21.png)","url":"https://sameep1234.github.io/notes/notes\\Q0Qv4OOrtgWPGOXojo4iy.html","relUrl":"notes\\Q0Qv4OOrtgWPGOXojo4iy.html"},{"doc":"Identity and Behaviour","title":"Identity and Behaviour","hpath":"courses.Semester 5.Identity and Behaviour","content":"\n","url":"https://sameep1234.github.io/notes/notes\\elcUWYUkVJfjM5NLR8toR.html","relUrl":"notes\\elcUWYUkVJfjM5NLR8toR.html"},{"doc":"Lecture 1","title":"Lecture 1","hpath":"courses.Semester 5.Identity and Behaviour.Lecture 1","content":"\n","url":"https://sameep1234.github.io/notes/notes\\D9wwwfHBU8FZT1kN8UJVO.html","relUrl":"notes\\D9wwwfHBU8FZT1kN8UJVO.html"},{"doc":"Heritage Conservation","title":"Heritage Conservation","hpath":"courses.Semester 5.Heritage Conservation","content":"\n","url":"https://sameep1234.github.io/notes/notes\\znYlAnqQDCB58XxxMMdIl.html","relUrl":"notes\\znYlAnqQDCB58XxxMMdIl.html"},{"doc":"Lecture 1","title":"Lecture 1","hpath":"courses.Semester 5.Heritage Conservation.Lecture 1","content":"\n","url":"https://sameep1234.github.io/notes/notes\\SJH5ZSmDfPD1UrQmDVlHq.html","relUrl":"notes\\SJH5ZSmDfPD1UrQmDVlHq.html"},{"doc":"Embedded Systems","title":"Embedded Systems","hpath":"courses.Semester 5.Embedded Systems","content":"\n","url":"https://sameep1234.github.io/notes/notes\\a1PatlsCiz7PYsL111lFm.html","relUrl":"notes\\a1PatlsCiz7PYsL111lFm.html"},{"doc":"Lecture 1","title":"Lecture 1","hpath":"courses.Semester 5.Embedded Systems.Lecture 1","content":"\n","url":"https://sameep1234.github.io/notes/notes\\wIwPNNBh5jeugRuj1Bhsv.html","relUrl":"notes\\wIwPNNBh5jeugRuj1Bhsv.html"},{"doc":"Changelog","title":"Changelog","hpath":"root.changelog","content":"","url":"https://sameep1234.github.io/notes/notes\\changelog.html","relUrl":"notes\\changelog.html"}]
